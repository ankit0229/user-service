from fastapi import FastAPI, Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from typing import List

from app.core.security import decode_jwt, JWTError  # Assuming a custom JWTError for decode issues


class JWTMiddleware(BaseHTTPMiddleware):
    def __init__(self, app: FastAPI, whitelist: List[str]):
        """
        Initialize the JWTMiddleware with the FastAPI app and a list of whitelisted paths.

        :param app: FastAPI app instance.
        :param whitelist: List of URL paths that do not require authentication.
        """
        super().__init__(app)
        self.whitelist = whitelist

    async def dispatch(self, request: Request, call_next):
        """
        Intercepts each request to check for JWT authentication.

        :param request: The incoming HTTP request.
        :param call_next: Function to call the next middleware or route handler.
        :return: The response generated by the next handler or a JSON error response.
        """
        try:
            if request.url.path not in self.whitelist:
                token = request.headers.get("Authorization")
                if not token:
                    raise HTTPException(status_code=403, detail="Not authenticated")

                if not token.startswith("Bearer "):
                    raise HTTPException(status_code=403, detail="Invalid authorization header format")

                token = token.split("Bearer ")[1]
                try:
                    payload = decode_jwt(token)
                except JWTError as e:
                    raise HTTPException(status_code=403, detail="Invalid token")

                if not payload:
                    raise HTTPException(status_code=403, detail="Invalid token")
                # Storing payload containing the user_id in request state
                request.state.user = payload
        except HTTPException as e:
            return JSONResponse({"detail": e.detail}, status_code=e.status_code)

        try:
            return await call_next(request)
        except HTTPException as e:
            raise e

